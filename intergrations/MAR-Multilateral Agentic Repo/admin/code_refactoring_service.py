"""
Code Refactoring Service - MAR Agent Generation System
Transforms discovered code patterns into standardized agent components
"""

import os
import ast
import json
import re
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path
from dataclasses import dataclass, asdict
from datetime import datetime

from llm.llm_service import query_llm


@dataclass
class CodePattern:
    """Represents a discovered code pattern that could become an agent"""
    pattern_id: str
    pattern_type: str  # "processor", "analyzer", "extractor", "validator", etc.
    source_file: str
    source_function: str
    functionality_description: str
    input_types: List[str]
    output_types: List[str]
    dependencies: List[str]
    complexity_score: float
    reusability_score: float


@dataclass
class AgentBlueprint:
    """Blueprint for generating a new agent"""
    agent_name: str
    agent_category: str
    core_functionality: str
    input_schema: Dict
    output_schema: Dict
    dependencies: List[str]
    compatible_llms: List[str]
    source_patterns: List[CodePattern]
    generated_code: str
    test_cases: List[Dict]


class CodeRefactoringService:
    """Service for transforming discovered code into MAR-compatible agents"""
    
    def __init__(self, mar_root: str = "MAR-Multilateral Agentic Repo"):
        self.mar_root = Path(mar_root)
        self.patterns_cache = {}
        self.agent_templates = self._load_agent_templates()
        
    def _load_agent_templates(self) -> Dict[str, str]:
        """Load agent code templates"""
        return {
            "base_agent": '''"""
{description}
Generated by MAR Code Refactoring Service
"""

from typing import Dict, List, Optional, Any
from shared.memory.memory_manager import MemoryManager
from shared.prompts.loader import load_prompt
from llm.llm_service import query_llm
from dataclasses import dataclass


@dataclass
class {agent_class_name}Input:
    {input_fields}


@dataclass  
class {agent_class_name}Output:
    {output_fields}


class {agent_class_name}:
    """
    {agent_description}
    
    Generated from source patterns:
    {source_patterns}
    """
    
    def __init__(self, config: Optional[Dict] = None):
        self.config = config or {{}}
        self.memory = MemoryManager()
        self.prompt_template = load_prompt("{agent_name}_prompt.txt")
        
    def process(self, input_data: {agent_class_name}Input) -> {agent_class_name}Output:
        """Main processing method"""
        {core_processing_logic}
        
    def _generate_prompt(self, input_data: {agent_class_name}Input) -> str:
        """Generate LLM prompt for this agent"""
        return self.prompt_template.format(**input_data.__dict__)
        
    def _post_process(self, raw_output: str, input_data: {agent_class_name}Input) -> {agent_class_name}Output:
        """Post-process LLM output into structured format"""
        {post_processing_logic}
        
    def run(self, input_data: {agent_class_name}Input) -> {agent_class_name}Output:
        """Execute the agent workflow"""
        try:
            result = self.process(input_data)
            self.memory.store_interaction(
                "{agent_name}", 
                input_data.__dict__, 
                result.__dict__
            )
            return result
        except Exception as e:
            raise Exception(f"{agent_class_name} execution failed: {{e}}")
''',
            
            "processor_agent": '''
    def process(self, input_data: {agent_class_name}Input) -> {agent_class_name}Output:
        """Process input data using extracted logic"""
        # Core logic extracted and refactored from: {source_file}
        {extracted_core_logic}
        
        # LLM enhancement for complex decisions
        if self._requires_llm_analysis(input_data):
            prompt = self._generate_prompt(input_data)
            llm_result = query_llm(prompt, model=self.config.get("model", "gpt-4o"))
            processed_data = self._integrate_llm_result(processed_data, llm_result)
            
        return self._format_output(processed_data)
''',
            
            "analyzer_agent": '''
    def process(self, input_data: {agent_class_name}Input) -> {agent_class_name}Output:
        """Analyze input using extracted patterns"""
        analysis_results = []
        
        # Pattern-based analysis from: {source_file}
        {extracted_analysis_logic}
        
        # LLM-enhanced analysis for complex patterns
        prompt = self._generate_analysis_prompt(input_data, analysis_results)
        enhanced_analysis = query_llm(prompt, model=self.config.get("model", "claude-3"))
        
        return self._synthesize_analysis(analysis_results, enhanced_analysis)
''',
            
            "extractor_agent": '''
    def process(self, input_data: {agent_class_name}Input) -> {agent_class_name}Output:
        """Extract structured data using learned patterns"""
        extraction_candidates = []
        
        # Rule-based extraction from: {source_file}
        {extracted_extraction_logic}
        
        # LLM validation and enhancement
        for candidate in extraction_candidates:
            validation_prompt = self._generate_validation_prompt(candidate)
            validation = query_llm(validation_prompt, model="gpt-4o")
            if self._is_valid_extraction(validation):
                candidate['confidence'] = self._calculate_confidence(validation)
                
        return self._compile_extractions(extraction_candidates)
'''
        }
    
    def analyze_code_patterns(self, discovered_metadata: List[Dict]) -> List[CodePattern]:
        """Analyze discovered code to identify reusable patterns"""
        patterns = []
        
        for item in discovered_metadata:
            try:
                # Read source code
                source_path = Path(item['file'])
                with open(source_path, 'r', encoding='utf-8') as f:
                    source_code = f.read()
                
                # Analyze with LLM
                analysis_prompt = f"""
                Analyze this code for agent generation potential:
                
                File: {item['file']}
                Function/Class: {item['name']}
                Type: {item['type']}
                
                Code:
                {item.get('source_code', 'N/A')}
                
                Determine:
                1. Pattern type (processor/analyzer/extractor/validator/other)
                2. Input/output types
                3. Core functionality description
                4. Dependencies required
                5. Reusability score (0-1)
                6. Complexity score (0-1)
                
                Return JSON format.
                """
                
                analysis = query_llm(analysis_prompt, model="gpt-4o")
                pattern_data = json.loads(analysis.get('output', '{}'))
                
                pattern = CodePattern(
                    pattern_id=item['id'],
                    pattern_type=pattern_data.get('pattern_type', 'unknown'),
                    source_file=item['file'],
                    source_function=item['name'],
                    functionality_description=pattern_data.get('functionality', ''),
                    input_types=pattern_data.get('input_types', []),
                    output_types=pattern_data.get('output_types', []),
                    dependencies=pattern_data.get('dependencies', []),
                    complexity_score=pattern_data.get('complexity_score', 0.5),
                    reusability_score=pattern_data.get('reusability_score', 0.5)
                )
                
                patterns.append(pattern)
                
            except Exception as e:
                print(f"❌ Failed to analyze pattern {item['id']}: {e}")
                
        return patterns
    
    def generate_agent_blueprint(self, patterns: List[CodePattern], agent_name: str) -> AgentBlueprint:
        """Generate agent blueprint from code patterns"""
        
        # Categorize patterns by functionality
        primary_pattern = max(patterns, key=lambda p: p.reusability_score)
        
        blueprint_prompt = f"""
        Create an agent blueprint from these code patterns:
        
        Primary Pattern: {primary_pattern.functionality_description}
        Source: {primary_pattern.source_file}
        
        Additional Patterns:
        {[p.functionality_description for p in patterns[1:]]}
        
        Generate:
        1. Agent name and category
        2. Core functionality description
        3. Input schema (JSON schema format)
        4. Output schema (JSON schema format)
        5. Compatible LLMs
        6. Test cases (3-5 examples)
        
        Agent should follow MAR methodology and be production-ready.
        Return JSON format.
        """
        
        blueprint_data = query_llm(blueprint_prompt, model="claude-3")
        blueprint_json = json.loads(blueprint_data.get('output', '{}'))
        
        return AgentBlueprint(
            agent_name=agent_name,
            agent_category=blueprint_json.get('category', 'utility'),
            core_functionality=blueprint_json.get('functionality', ''),
            input_schema=blueprint_json.get('input_schema', {}),
            output_schema=blueprint_json.get('output_schema', {}),
            dependencies=blueprint_json.get('dependencies', []),
            compatible_llms=blueprint_json.get('compatible_llms', ['gpt-4o']),
            source_patterns=patterns,
            generated_code='',  # Will be filled by generate_agent_code
            test_cases=blueprint_json.get('test_cases', [])
        )
    
    def generate_agent_code(self, blueprint: AgentBlueprint) -> str:
        """Generate complete agent code from blueprint"""
        
        # Extract core logic from source patterns
        extracted_logic = self._extract_core_logic(blueprint.source_patterns)
        
        # Determine agent template based on primary pattern type
        primary_type = blueprint.source_patterns[0].pattern_type
        template_key = f"{primary_type}_agent" if f"{primary_type}_agent" in self.agent_templates else "base_agent"
        
        # Generate code using template
        agent_class_name = self._to_class_name(blueprint.agent_name)
        
        code = self.agent_templates[template_key].format(
            description=blueprint.core_functionality,
            agent_class_name=agent_class_name,
            agent_name=blueprint.agent_name,
            agent_description=blueprint.core_functionality,
            input_fields=self._generate_dataclass_fields(blueprint.input_schema),
            output_fields=self._generate_dataclass_fields(blueprint.output_schema),
            source_patterns=[p.source_file for p in blueprint.source_patterns],
            core_processing_logic=extracted_logic.get('core_logic', 'pass'),
            post_processing_logic=extracted_logic.get('post_processing', 'pass'),
            source_file=blueprint.source_patterns[0].source_file,
            extracted_core_logic=extracted_logic.get('extracted_logic', '# Logic extraction needed'),
            extracted_analysis_logic=extracted_logic.get('analysis_logic', '# Analysis logic needed'),
            extracted_extraction_logic=extracted_logic.get('extraction_logic', '# Extraction logic needed')
        )
        
        return code
    
    def _extract_core_logic(self, patterns: List[CodePattern]) -> Dict[str, str]:
        """Extract and refactor core logic from source patterns"""
        logic_prompt = f"""
        Extract and refactor the core logic from these code patterns for agent generation:
        
        Patterns:
        {[{
            'file': p.source_file,
            'function': p.source_function, 
            'type': p.pattern_type,
            'description': p.functionality_description
        } for p in patterns]}
        
        Generate refactored code that:
        1. Removes file I/O and makes it data-driven
        2. Separates core logic from infrastructure
        3. Makes it reusable and configurable
        4. Follows clean code principles
        
        Return:
        - core_logic: Main processing logic
        - post_processing: Output formatting logic
        - extracted_logic: Specific extracted patterns
        - analysis_logic: Analysis-specific logic (if applicable)
        - extraction_logic: Extraction-specific logic (if applicable)
        
        Return as JSON.
        """
        
        result = query_llm(logic_prompt, model="claude-3")
        return json.loads(result.get('output', '{}'))
    
    def _to_class_name(self, agent_name: str) -> str:
        """Convert agent name to valid class name"""
        return ''.join(word.capitalize() for word in re.split(r'[_\-\s]+', agent_name))
    
    def _generate_dataclass_fields(self, schema: Dict) -> str:
        """Generate dataclass fields from JSON schema"""
        if not schema.get('properties'):
            return "data: Any"
            
        fields = []
        for field_name, field_def in schema['properties'].items():
            field_type = self._json_type_to_python_type(field_def.get('type', 'string'))
            required = field_name in schema.get('required', [])
            default = '' if required else ' = None'
            fields.append(f"    {field_name}: {field_type}{default}")
            
        return '\n'.join(fields)
    
    def _json_type_to_python_type(self, json_type: str) -> str:
        """Convert JSON schema type to Python type annotation"""
        type_mapping = {
            'string': 'str',
            'integer': 'int', 
            'number': 'float',
            'boolean': 'bool',
            'array': 'List[Any]',
            'object': 'Dict[str, Any]'
        }
        return type_mapping.get(json_type, 'Any')
    
    def create_agent_from_patterns(self, patterns: List[CodePattern], agent_name: str) -> AgentBlueprint:
        """Complete workflow: patterns -> blueprint -> code"""
        print(f"🔧 Creating agent '{agent_name}' from {len(patterns)} patterns...")
        
        # Generate blueprint
        blueprint = self.generate_agent_blueprint(patterns, agent_name)
        
        # Generate code
        blueprint.generated_code = self.generate_agent_code(blueprint)
        
        # Save agent
        self._save_agent(blueprint)
        
        return blueprint
    
    def _save_agent(self, blueprint: AgentBlueprint):
        """Save generated agent to MAR structure"""
        # Create agent directory
        agent_dir = self.mar_root / "agents" / blueprint.agent_category
        agent_dir.mkdir(parents=True, exist_ok=True)
        
        # Save agent code
        agent_file = agent_dir / f"{blueprint.agent_name}_agent.py"
        with open(agent_file, 'w', encoding='utf-8') as f:
            f.write(blueprint.generated_code)
            
        # Create prompt template
        prompt_dir = self.mar_root / "shared" / "prompts"
        prompt_dir.mkdir(parents=True, exist_ok=True)
        prompt_file = prompt_dir / f"{blueprint.agent_name}_prompt.txt"
        
        with open(prompt_file, 'w', encoding='utf-8') as f:
            f.write(f"You are a {blueprint.core_functionality} agent.\n\n")
            f.write("Process the following input:\n{data}\n\n")
            f.write("Return structured output following the specified schema.")
        
        # Update agent registry
        self._update_agent_registry(blueprint)
        
        print(f"✅ Agent '{blueprint.agent_name}' saved to {agent_file}")
    
    def _update_agent_registry(self, blueprint: AgentBlueprint):
        """Update the MAR agent registry with new agent"""
        registry_path = self.mar_root / "configs" / "agent_registry.json"
        
        # Load existing registry
        if registry_path.exists():
            with open(registry_path, 'r') as f:
                registry = json.load(f)
        else:
            registry = []
            
        # Add new agent
        agent_entry = {
            "name": f"{blueprint.agent_name}_agent",
            "category": blueprint.agent_category,
            "smart": True,
            "compatible_llms": blueprint.compatible_llms,
            "protocols": ["MCP", "SCIP"],
            "functionality": blueprint.core_functionality,
            "generated_from": [p.source_file for p in blueprint.source_patterns],
            "created_at": datetime.now().isoformat()
        }
        
        # Update or add
        existing_idx = next((i for i, agent in enumerate(registry) 
                           if agent.get('name') == agent_entry['name']), None)
        
        if existing_idx is not None:
            registry[existing_idx] = agent_entry
        else:
            registry.append(agent_entry)
            
        # Save registry
        with open(registry_path, 'w') as f:
            json.dump(registry, f, indent=2)


# Example usage and testing
if __name__ == "__main__":
    refactoring_service = CodeRefactoringService()
    
    # Example: Create agent from discovered patterns
    sample_patterns = [
        CodePattern(
            pattern_id="search_engine_001",
            pattern_type="processor", 
            source_file="Rank_AI/01_search_discovery/ai_search_engine.py",
            source_function="discover_esg_reports",
            functionality_description="AI-powered ESG report discovery using search APIs",
            input_types=["str", "int"],
            output_types=["List[SearchResult]"],
            dependencies=["requests", "openai"],
            complexity_score=0.7,
            reusability_score=0.9
        )
    ]
    
    # Generate agent
    blueprint = refactoring_service.create_agent_from_patterns(
        sample_patterns, 
        "esg_report_discoverer"
    )
    
    print(f"Generated agent: {blueprint.agent_name}")
    print(f"Category: {blueprint.agent_category}")
    print(f"Code length: {len(blueprint.generated_code)} characters")


